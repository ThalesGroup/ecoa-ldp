/* Copyright (c) 2025 THALES -- All rights reserved */

/*
 * @file Philosopher.c
 * Module Interface for Module Philosopher
 * This file can be considered a template with the operation stubs
 * auto generated by the ECOA toolset and filled in by the module
 * developer.
 */

/* Include module interface header */
#include "Philosopher.h"
#include <stdio.h>


static const ECOA__hr_time EatPeriod = { 1, 0 }; 
static const ECOA__hr_time ThinkPeriod = { 2, 0 };

const char* philosopher__State_value(philosopher__State state){
  static const char* philosopher__State_strings[] =
		{"(unknown)", "philosopher__State_UNDEFINED", "philosopher__State_GETTINGSTICKS", "philosopher__State_EATING",
				"philosopher__State_SURRENDERING", "philosopher__State_THINKING" };
	//
	switch( state ){
		case philosopher__State_UNDEFINED:
		case philosopher__State_GETTINGSTICKS:
		case philosopher__State_EATING:
		case philosopher__State_SURRENDERING:
		case philosopher__State_THINKING:
			return philosopher__State_strings[state+1];
		default:
			return philosopher__State_strings[0];
	}
}

ECOA__hr_time timeAdd( ECOA__hr_time l, ECOA__hr_time r )
{
	ECOA__hr_time res;
	//
	res.seconds     = l.seconds     + r.seconds;
	res.nanoseconds = l.nanoseconds + r.nanoseconds;
	while( res.nanoseconds > 1000000000LL ){
		res.seconds     += 1;
		res.nanoseconds -= 1000000000LL;
	}
	return res;
}

int timecmp( ECOA__hr_time l, ECOA__hr_time r )
{
	if (l.seconds < r.seconds) {
        return -1;
    } else if (l.seconds > r.seconds) {
        return 1;
    } else {
        if (l.nanoseconds < r.nanoseconds) {
            return -1;
        } else if (l.nanoseconds > r.nanoseconds) {
            return 1;
        } else {
            return 0;
        }
    }
}

/* Event operation handlers */
void 
Philosopher__tick__received (
  Philosopher__context* context
 )
{
  ECOA__uint32 IAm;
  ECOA__log msg;
  ECOA__return_status erc;
  ECOA__hr_time timeNow;
  ECOA__boolean8 Taken, TableLaid;
  ECOA__int32 LeftStick, RightStick;
  Philosopher_container__ready_handle rdyHndl;


  Philosopher_container__get_Id_value(context, &IAm);

  ECOA__duration delay = { 1, 0};
  Philosopher_container__ticker__set(context, delay);

  LeftStick = IAm - 1;
  RightStick = IAm %5;
  Philosopher_container__get_relative_local_time(context, & timeNow);
  msg.current_size = sprintf( msg.data, "Philosopher %d Tick. State = %s", IAm, philosopher__State_value( context->user.PhiloState ) );
  //Philosopher_container__log_info( context, msg );
  Philosopher_container__ready__get_read_access(context, &rdyHndl);
  TableLaid = *(rdyHndl.data);
  Philosopher_container__ready__release_read_access(context, &rdyHndl);
  if( !TableLaid ){
    msg.current_size = sprintf( msg.data, "Philosopher %d Tick, but Chopsticks not available...", IAm );
    Philosopher_container__log_info( context, msg );
    return;
  }

  if( context->user.PhiloState == philosopher__State_GETTINGSTICKS ){
    // **********************************************
    // * Dijkstra's Resource Hierarchy Solution.... *
    // **********************************************
    // The lower numbered chopstick is always taken first...
    /**/
    if( RightStick < LeftStick ){ 
      if( !context->user.HaveRightStick ){ 
        if(( erc = Philosopher_container__take__request_sync( context, RightStick, IAm, &Taken )) != ECOA__return_status_OK ){ 
          msg.current_size = sprintf( msg.data, "take__request( RightStick=>%d, by=>%d ) failed with %d", 
          RightStick, IAm, erc ); 
          Philosopher_container__log_info( context, msg ); 
        } 
        if( !Taken ){ 
          return; // We'll have another go on the next tick...
        } else { 
         context->user.HaveRightStick = ECOA__TRUE;
        }
      }
    }

    if( !context->user.HaveLeftStick ){ 
      if(( erc = Philosopher_container__take__request_sync( context, LeftStick, IAm, &Taken )) != ECOA__return_status_OK ){ 
        msg.current_size = sprintf( msg.data, "take__request( LeftStick=>%d, by=>%d ) failed with %d", 
        LeftStick, IAm, erc ); 
        Philosopher_container__log_info( context, msg ); 
      } 
      if( !Taken ){ 
        return; // We'll have another go on the next tick...
      } else { 
        context->user.HaveLeftStick = ECOA__TRUE; 
      } 
    }

    if( RightStick > LeftStick ){ 
      if( !context->user.HaveRightStick ){ 
        if(( erc = Philosopher_container__take__request_sync( context, RightStick, IAm, &Taken )) != ECOA__return_status_OK ){ 
          msg.current_size = sprintf( msg.data, "take__request( RightStick=>%d, by=>%d ) failed with %d", 
          RightStick, IAm, erc ); 
          Philosopher_container__log_info( context, msg ); 
        } 
        if( !Taken ){ 
          return; // We'll have another go on the next tick...
        } else { 
          context->user.HaveRightStick = ECOA__TRUE; 
        } 
      }
    }

    printf( "%d begin eating.\n", IAm ); 
    context->user.PhiloState = philosopher__State_EATING; 
    context->user.EatUntil = timeAdd( timeNow, EatPeriod );
  }

  if( context->user.PhiloState == philosopher__State_EATING ){ 
    if( timecmp( timeNow, context->user.EatUntil ) < 0 ){ 
      return;
    } else { 
      printf( "%d finished eating.\n", IAm ); 
      context->user.PhiloState = philosopher__State_SURRENDERING; 
    } 
  } 

  if( context->user.PhiloState == philosopher__State_SURRENDERING ){
    if(( erc = Philosopher_container__surrender__request_sync( context, LeftStick, IAm )) != ECOA__return_status_OK ){ 
      msg.current_size = sprintf( msg.data, "\n\tPhilosopher %d failed to surrender chopstick %d...\n", IAm, 
      LeftStick ); 
      Philosopher_container__log_info( context, msg ); 
    } 
    if(( erc = Philosopher_container__surrender__request_sync( context, RightStick, IAm )) != ECOA__return_status_OK ){ 
      msg.current_size = sprintf( msg.data, "\n\tPhilosopher %d failed to surrender chopstick %d...\n", IAm, RightStick ); 
      Philosopher_container__log_info( context, msg ); 
    }  
    context->user.HaveLeftStick = context->user.HaveRightStick = ECOA__FALSE; 
    printf( "%d begin thinking.\n", IAm ); 
    context->user.PhiloState = philosopher__State_THINKING; 
    context->user.ThinkUntil = timeAdd( timeNow, ThinkPeriod );  

  }

  if( context->user.PhiloState == philosopher__State_THINKING ){ 
    if( timecmp( timeNow, context->user.ThinkUntil ) < 0 ) { 
      return; // Still cogitating...
    } 
    printf( "%d finished thinking.\n", IAm ); 
    context->user.PhiloState = philosopher__State_GETTINGSTICKS; 
  }

  if( context->user.PhiloState <= philosopher__State_UNDEFINED ||  context->user.PhiloState > philosopher__State_THINKING ){ 
    msg.current_size = sprintf( msg.data, "\n\tPhilosopher %d has illegal state %s...\n", IAm, philosopher__State_value( 
    context->user.PhiloState )); 
    Philosopher_container__log_info( context, msg ); 
    return; 
  } 
} 

/* Lifecycle operation handlers */

void Philosopher__INITIALIZE__received(Philosopher__context* context)
{
  context->user.PhiloState = philosopher__State_UNDEFINED; 
  context->user.EatUntil = (ECOA__hr_time){ 0, 0 }; 
  context->user.ThinkUntil = (ECOA__hr_time){ 0, 0 }; 
  context->user.HaveLeftStick = ECOA__FALSE; 
  context->user.HaveRightStick = ECOA__FALSE; 
}
void Philosopher__START__received(Philosopher_context* context)
{
  ECOA__uint32 IAm; 
  ECOA__log msg; 
  //
   ECOA__duration delay = { 1, 0};
  context->user.PhiloState = philosopher__State_GETTINGSTICKS; 
  Philosopher_container__ticker__set(context, delay);
  //
  Philosopher_container__get_Id_value( context, &IAm ); 
  msg.current_size = sprintf( msg.data, "\n\tPhilosopher %d is ready...\n", IAm ); 
  Philosopher_container__log_info( context, msg );
}
void Philosopher__STOP__received(Philosopher_context* context)
{
  /* TODO: to be implemented */
}
void Philosopher__SHUTDOWN__received(Philosopher_context* context)
{
  /* TODO: to be implemented */
}


  