// Copyright (c) 2025 THALES -- All rights reserved

import "../../shared/function_names.stg"

initializeSource(model) ::=<<
#include "<model.fileprefix>_initialize.h"

<if(model.hasStrings)>
#include \<string.h\>
<endif>

<model.types : { type | 
<if (type.isEnum)>
<initializeEnum(type)>
<elseif (type.isSimple)>
<initializeSimple(type)>
<elseif (type.isRecord)>
<initializeRecord(type)>
<equalsRecord(type)>
<elseif (type.isVariantRecord)>
<initializeVariantRecord(type)>
<equalsVariantRecord(type)>
<elseif (type.isArray)>
<initializeArray(type)>
<equalsArray(type)>
<elseif (type.isFixedArray)>
<initializeFixedArray(type)>
<equalsFixedArray(type)>
<elseif (type.isString)>
<initializeString(type)>
<equalsString(type)>
<endif>
}>

>>

initializeSignature(type) ::=<<
void <initializeFunctionName(type)> (<type.qName> *v)
>>

equalsSignature(type) ::=<<
ECOA__boolean8 <equalsFunctionName(type)> (const <type.qName> *v1, const <type.qName> *v2)
>>

//-------------------------------
//@name Equals method call
//@param t Im_Gentype.TypeDefinition
//@param suffix String
equals(t,v1,v2) ::=<<
<if(t.isScalar)><v1> == <v2><else><equalsFunctionName(t)>(&<v1>,&<v2>)<endif>
>>

//-------------------------------
//@name Equals method call
//@param t Im_Gentype.TypeDefinition
//@param suffix String
returnFalseIfNotEqual(t,suffix) ::=<<
if (!(<equals(t,{v1-\><suffix>},{v2-\><suffix>})>)) return ECOA__FALSE
>>

//=============================================================================
// Simple types initialization
//=============================================================================

//=============================================
//@name Simple types initialization
//@param simple Im_Gentype.TypeDefinition
initializeSimple(simple) ::=<<
<initializeSignature(simple)>
{
  <initializeFunctionName(simple.type)>(v);
}
>>

//=============================================================================
// Record types initialization
//=============================================================================

//=============================================
//@name Record types initialization
//@param type Im_Gentype.TypeDefinition
initializeRecord(type) ::=<<
<initializeSignature(type)>
{
  <type.fields : { field | 
  <field.qType>__initialize(&v-><field.name>);
  }>
\}

>>

//=============================================================================
// Variant record types initialization
//=============================================================================

//=============================================
//@name Variant record types initialization
//@param type Im_Gentype.TypeDefinition
initializeVariantRecord(type) ::=<<
<initializeSignature(type)>
{
  v-><type.selectName> = <type.qWhen1>;

  <type.fields : { field | 
  <field.qType>__initialize (&v-><field.name>);
  }>

  <first(type.unionFields).qType>__initialize (&v->u_<type.selectName>.<first(type.unionFields).name>);
\}

>>

//=============================================================================
// Array types initialization
//=============================================================================

//=============================================
//@name Array types initialization
//@param type Im_Gentype.TypeDefinition
initializeArray(type) ::=<<
<initializeSignature(type)>
{
  v->current_size = 0;
\}

>>

//=============================================================================
// Fixed array types initialization
//=============================================================================

//=============================================
//@name Fixed array types initialization
//@param type Im_Gentype.TypeDefinition
initializeFixedArray(type) ::=<<
<initializeSignature(type)>
{
  ECOA__uint32 index = 0;

  while (index \< <type.qName>_MAXSIZE)
    {
      <type.qType>__initialize (&v->data[index]);
      ++index;
    \}
\}

>>

//=============================================================================
// Enum types initialization
//=============================================================================

//=============================================
//@name Enum types initialization
//@param type Im_Gentype.TypeDefinition
initializeEnum(type) ::=<<
<initializeSignature(type)>
{
    *v = <first(type.sortedEnumValues).valnumLitteral>;
\}

>>

//=============================================================================
// String types initialization
//=============================================================================

//=============================================
//@name String types initialization
//@param type Im_Gentype.TypeDefinition
initializeString(type) ::=<<
<initializeSignature(type)>
{
  v->max_length = <type.qName>_MAXLEN;
  v->current_length = 0;
  v->data[0] = '\0';
\}

>>


//=============================================================================
// Comparison functions
//=============================================================================

//=============================================
//@name Record types comparison
//@param type Im_Gentype.TypeDefinition
equalsRecord(type) ::=<<
<equalsSignature(type)>
{
<type.fields : { field |
  <returnFalseIfNotEqual(field.type,field.name)>;
}>
  return ECOA__TRUE;
}

>>

//=============================================
//@name Variant Record types comparison
//@param type Im_Gentype.TypeDefinition
equalsVariantRecord(type) ::=<<
<equalsSignature(type)>
{
<type.fields : { field |
  <returnFalseIfNotEqual(field.type,field.name)>;
}>
  <returnFalseIfNotEqual(type.type,type.selectName)>;
  switch (v1-\><type.selectName>)
    {
<type.unionFields : { union | 
    case <union.qWhen>:
      <returnFalseIfNotEqual(union.type,{u_<type.selectName>.<union.name>})>;
      break;
}>
    default:
<if(type.defaultUnionField)>
      <returnFalseIfNotEqual(type.defaultUnionField.type,{u_<type.selectName>.<type.defaultUnionField.name>})>;
<endif>
      break;
    \}
  return ECOA__TRUE;
}


>>

//=============================================
//@name Array types comparison
//@param type Im_Gentype.TypeDefinition
equalsArray(type) ::=<<
<equalsSignature(type)>
{
  ECOA__uint32 index = 0;

  if (v1-\>current_size != v2-\>current_size) return ECOA__FALSE;
  for (index = 0; index \< v1-\>current_size; index++)
    {
      <returnFalseIfNotEqual(type.type,{data[index]})>;
    \}
  return ECOA__TRUE;
}

>>

//=============================================
//@name Fixed Array types comparison
//@param type Im_Gentype.TypeDefinition
equalsFixedArray(type) ::=<<
<equalsSignature(type)>
{
  ECOA__uint32 index = 0;
  for (index = 0; index \< <type.qName>_MAXSIZE; index++)
  {
      <returnFalseIfNotEqual(type.type,{data[index]})>;
  \}
  return ECOA__TRUE;
\}

>>


//=============================================
//@name String types comparison
//@param type Im_Gentype.TypeDefinition
equalsString(type) ::=<<
<equalsSignature(type)>
{
  if (strcmp(v1-\>data, v2-\>data) != 0) return ECOA__FALSE;
  return ECOA__TRUE;
\}

>>
